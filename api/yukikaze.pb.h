// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yukikaze.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_yukikaze_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_yukikaze_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_yukikaze_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_yukikaze_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_yukikaze_2eproto;
namespace yukikaze {
class CancelRequest;
struct CancelRequestDefaultTypeInternal;
extern CancelRequestDefaultTypeInternal _CancelRequest_default_instance_;
class CancelResponse;
struct CancelResponseDefaultTypeInternal;
extern CancelResponseDefaultTypeInternal _CancelResponse_default_instance_;
class EncodeRequest;
struct EncodeRequestDefaultTypeInternal;
extern EncodeRequestDefaultTypeInternal _EncodeRequest_default_instance_;
class EncodeResponse;
struct EncodeResponseDefaultTypeInternal;
extern EncodeResponseDefaultTypeInternal _EncodeResponse_default_instance_;
class StatusRequest;
struct StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace yukikaze
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace yukikaze {
enum Decoder : int {
  DEFAULT = 0,
  QSV = 1,
  CUVID = 2,
  Decoder_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Decoder_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Decoder_IsValid(int value);
constexpr Decoder Decoder_MIN = static_cast<Decoder>(0);
constexpr Decoder Decoder_MAX = static_cast<Decoder>(2);
constexpr int Decoder_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Decoder_descriptor();
template <typename T>
const std::string& Decoder_Name(T value) {
  static_assert(std::is_same<T, Decoder>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Decoder_Name().");
  return Decoder_Name(static_cast<Decoder>(value));
}
template <>
inline const std::string& Decoder_Name(Decoder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Decoder_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Decoder_Parse(absl::string_view name, Decoder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Decoder>(
      Decoder_descriptor(), name, value);
}
enum EncoderType : int {
  X264 = 0,
  X265 = 1,
  QSVENC = 2,
  NVENC = 3,
  VCEENC = 4,
  SVT_AV1 = 5,
  EncoderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EncoderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EncoderType_IsValid(int value);
constexpr EncoderType EncoderType_MIN = static_cast<EncoderType>(0);
constexpr EncoderType EncoderType_MAX = static_cast<EncoderType>(5);
constexpr int EncoderType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
EncoderType_descriptor();
template <typename T>
const std::string& EncoderType_Name(T value) {
  static_assert(std::is_same<T, EncoderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncoderType_Name().");
  return EncoderType_Name(static_cast<EncoderType>(value));
}
template <>
inline const std::string& EncoderType_Name(EncoderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncoderType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool EncoderType_Parse(absl::string_view name, EncoderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncoderType>(
      EncoderType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class EncodeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yukikaze.EncodeRequest) */ {
 public:
  inline EncodeRequest() : EncodeRequest(nullptr) {}
  ~EncodeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EncodeRequest(::google::protobuf::internal::ConstantInitialized);

  EncodeRequest(const EncodeRequest& from);
  EncodeRequest(EncodeRequest&& from) noexcept
    : EncodeRequest() {
    *this = ::std::move(from);
  }

  inline EncodeRequest& operator=(const EncodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodeRequest& operator=(EncodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncodeRequest* internal_default_instance() {
    return reinterpret_cast<const EncodeRequest*>(
               &_EncodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EncodeRequest& a, EncodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EncodeRequest& from) {
    EncodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.EncodeRequest";
  }
  protected:
  explicit EncodeRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputNameFieldNumber = 1,
    kOutputNameFieldNumber = 2,
    kEncoderFieldNumber = 13,
    kEncoderOptionFieldNumber = 14,
    kServiceIdFieldNumber = 3,
    kEncoderTypeFieldNumber = 4,
    kDisableChapterFieldNumber = 5,
    kDisableDelogoFieldNumber = 6,
    kIgnoreNoLogoFieldNumber = 7,
    kEnableSubtitlesFieldNumber = 8,
    kIgnoreNoDrcsmapFieldNumber = 9,
    kMpeg2DecoderFieldNumber = 10,
    kH264DecoderFieldNumber = 11,
    kCmoutmaskFieldNumber = 12,
  };
  // string input_name = 1;
  void clear_input_name() ;
  const std::string& input_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_name(Arg_&& arg, Args_... args);
  std::string* mutable_input_name();
  PROTOBUF_NODISCARD std::string* release_input_name();
  void set_allocated_input_name(std::string* ptr);

  private:
  const std::string& _internal_input_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_name(
      const std::string& value);
  std::string* _internal_mutable_input_name();

  public:
  // string output_name = 2;
  void clear_output_name() ;
  const std::string& output_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_output_name(Arg_&& arg, Args_... args);
  std::string* mutable_output_name();
  PROTOBUF_NODISCARD std::string* release_output_name();
  void set_allocated_output_name(std::string* ptr);

  private:
  const std::string& _internal_output_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_name(
      const std::string& value);
  std::string* _internal_mutable_output_name();

  public:
  // string encoder = 13;
  void clear_encoder() ;
  const std::string& encoder() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encoder(Arg_&& arg, Args_... args);
  std::string* mutable_encoder();
  PROTOBUF_NODISCARD std::string* release_encoder();
  void set_allocated_encoder(std::string* ptr);

  private:
  const std::string& _internal_encoder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoder(
      const std::string& value);
  std::string* _internal_mutable_encoder();

  public:
  // string encoder_option = 14;
  void clear_encoder_option() ;
  const std::string& encoder_option() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encoder_option(Arg_&& arg, Args_... args);
  std::string* mutable_encoder_option();
  PROTOBUF_NODISCARD std::string* release_encoder_option();
  void set_allocated_encoder_option(std::string* ptr);

  private:
  const std::string& _internal_encoder_option() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoder_option(
      const std::string& value);
  std::string* _internal_mutable_encoder_option();

  public:
  // uint32 service_id = 3;
  void clear_service_id() ;
  ::uint32_t service_id() const;
  void set_service_id(::uint32_t value);

  private:
  ::uint32_t _internal_service_id() const;
  void _internal_set_service_id(::uint32_t value);

  public:
  // .yukikaze.EncoderType encoder_type = 4;
  void clear_encoder_type() ;
  ::yukikaze::EncoderType encoder_type() const;
  void set_encoder_type(::yukikaze::EncoderType value);

  private:
  ::yukikaze::EncoderType _internal_encoder_type() const;
  void _internal_set_encoder_type(::yukikaze::EncoderType value);

  public:
  // bool disable_chapter = 5;
  void clear_disable_chapter() ;
  bool disable_chapter() const;
  void set_disable_chapter(bool value);

  private:
  bool _internal_disable_chapter() const;
  void _internal_set_disable_chapter(bool value);

  public:
  // bool disable_delogo = 6;
  void clear_disable_delogo() ;
  bool disable_delogo() const;
  void set_disable_delogo(bool value);

  private:
  bool _internal_disable_delogo() const;
  void _internal_set_disable_delogo(bool value);

  public:
  // bool ignore_no_logo = 7;
  void clear_ignore_no_logo() ;
  bool ignore_no_logo() const;
  void set_ignore_no_logo(bool value);

  private:
  bool _internal_ignore_no_logo() const;
  void _internal_set_ignore_no_logo(bool value);

  public:
  // bool enable_subtitles = 8;
  void clear_enable_subtitles() ;
  bool enable_subtitles() const;
  void set_enable_subtitles(bool value);

  private:
  bool _internal_enable_subtitles() const;
  void _internal_set_enable_subtitles(bool value);

  public:
  // bool ignore_no_drcsmap = 9;
  void clear_ignore_no_drcsmap() ;
  bool ignore_no_drcsmap() const;
  void set_ignore_no_drcsmap(bool value);

  private:
  bool _internal_ignore_no_drcsmap() const;
  void _internal_set_ignore_no_drcsmap(bool value);

  public:
  // .yukikaze.Decoder mpeg2_decoder = 10;
  void clear_mpeg2_decoder() ;
  ::yukikaze::Decoder mpeg2_decoder() const;
  void set_mpeg2_decoder(::yukikaze::Decoder value);

  private:
  ::yukikaze::Decoder _internal_mpeg2_decoder() const;
  void _internal_set_mpeg2_decoder(::yukikaze::Decoder value);

  public:
  // .yukikaze.Decoder h264_decoder = 11;
  void clear_h264_decoder() ;
  ::yukikaze::Decoder h264_decoder() const;
  void set_h264_decoder(::yukikaze::Decoder value);

  private:
  ::yukikaze::Decoder _internal_h264_decoder() const;
  void _internal_set_h264_decoder(::yukikaze::Decoder value);

  public:
  // int32 cmoutmask = 12;
  void clear_cmoutmask() ;
  ::int32_t cmoutmask() const;
  void set_cmoutmask(::int32_t value);

  private:
  ::int32_t _internal_cmoutmask() const;
  void _internal_set_cmoutmask(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:yukikaze.EncodeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14, 0, 81, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr input_name_;
    ::google::protobuf::internal::ArenaStringPtr output_name_;
    ::google::protobuf::internal::ArenaStringPtr encoder_;
    ::google::protobuf::internal::ArenaStringPtr encoder_option_;
    ::uint32_t service_id_;
    int encoder_type_;
    bool disable_chapter_;
    bool disable_delogo_;
    bool ignore_no_logo_;
    bool enable_subtitles_;
    bool ignore_no_drcsmap_;
    int mpeg2_decoder_;
    int h264_decoder_;
    ::int32_t cmoutmask_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yukikaze_2eproto;
};// -------------------------------------------------------------------

class EncodeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yukikaze.EncodeResponse) */ {
 public:
  inline EncodeResponse() : EncodeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EncodeResponse(::google::protobuf::internal::ConstantInitialized);

  EncodeResponse(const EncodeResponse& from);
  EncodeResponse(EncodeResponse&& from) noexcept
    : EncodeResponse() {
    *this = ::std::move(from);
  }

  inline EncodeResponse& operator=(const EncodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodeResponse& operator=(EncodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncodeResponse* internal_default_instance() {
    return reinterpret_cast<const EncodeResponse*>(
               &_EncodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EncodeResponse& a, EncodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncodeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EncodeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EncodeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.EncodeResponse";
  }
  protected:
  explicit EncodeResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yukikaze.EncodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_yukikaze_2eproto;
};// -------------------------------------------------------------------

class StatusRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yukikaze.StatusRequest) */ {
 public:
  inline StatusRequest() : StatusRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusRequest(::google::protobuf::internal::ConstantInitialized);

  StatusRequest(const StatusRequest& from);
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.StatusRequest";
  }
  protected:
  explicit StatusRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yukikaze.StatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_yukikaze_2eproto;
};// -------------------------------------------------------------------

class StatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yukikaze.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::google::protobuf::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.StatusResponse";
  }
  protected:
  explicit StatusResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 1,
  };
  // bytes log = 1;
  void clear_log() ;
  const std::string& log() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log(Arg_&& arg, Args_... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* ptr);

  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(
      const std::string& value);
  std::string* _internal_mutable_log();

  public:
  // @@protoc_insertion_point(class_scope:yukikaze.StatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr log_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yukikaze_2eproto;
};// -------------------------------------------------------------------

class CancelRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yukikaze.CancelRequest) */ {
 public:
  inline CancelRequest() : CancelRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CancelRequest(::google::protobuf::internal::ConstantInitialized);

  CancelRequest(const CancelRequest& from);
  CancelRequest(CancelRequest&& from) noexcept
    : CancelRequest() {
    *this = ::std::move(from);
  }

  inline CancelRequest& operator=(const CancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelRequest& operator=(CancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelRequest* internal_default_instance() {
    return reinterpret_cast<const CancelRequest*>(
               &_CancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CancelRequest& a, CancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.CancelRequest";
  }
  protected:
  explicit CancelRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yukikaze.CancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_yukikaze_2eproto;
};// -------------------------------------------------------------------

class CancelResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yukikaze.CancelResponse) */ {
 public:
  inline CancelResponse() : CancelResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CancelResponse(::google::protobuf::internal::ConstantInitialized);

  CancelResponse(const CancelResponse& from);
  CancelResponse(CancelResponse&& from) noexcept
    : CancelResponse() {
    *this = ::std::move(from);
  }

  inline CancelResponse& operator=(const CancelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponse& operator=(CancelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponse* internal_default_instance() {
    return reinterpret_cast<const CancelResponse*>(
               &_CancelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CancelResponse& a, CancelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "yukikaze.CancelResponse";
  }
  protected:
  explicit CancelResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yukikaze.CancelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_yukikaze_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EncodeRequest

// string input_name = 1;
inline void EncodeRequest::clear_input_name() {
  _impl_.input_name_.ClearToEmpty();
}
inline const std::string& EncodeRequest::input_name() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.input_name)
  return _internal_input_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncodeRequest::set_input_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.input_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.input_name)
}
inline std::string* EncodeRequest::mutable_input_name() {
  std::string* _s = _internal_mutable_input_name();
  // @@protoc_insertion_point(field_mutable:yukikaze.EncodeRequest.input_name)
  return _s;
}
inline const std::string& EncodeRequest::_internal_input_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.input_name_.Get();
}
inline void EncodeRequest::_internal_set_input_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.input_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EncodeRequest::_internal_mutable_input_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.input_name_.Mutable( GetArenaForAllocation());
}
inline std::string* EncodeRequest::release_input_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:yukikaze.EncodeRequest.input_name)
  return _impl_.input_name_.Release();
}
inline void EncodeRequest::set_allocated_input_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.input_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_name_.IsDefault()) {
          _impl_.input_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yukikaze.EncodeRequest.input_name)
}

// string output_name = 2;
inline void EncodeRequest::clear_output_name() {
  _impl_.output_name_.ClearToEmpty();
}
inline const std::string& EncodeRequest::output_name() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.output_name)
  return _internal_output_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncodeRequest::set_output_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.output_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.output_name)
}
inline std::string* EncodeRequest::mutable_output_name() {
  std::string* _s = _internal_mutable_output_name();
  // @@protoc_insertion_point(field_mutable:yukikaze.EncodeRequest.output_name)
  return _s;
}
inline const std::string& EncodeRequest::_internal_output_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_name_.Get();
}
inline void EncodeRequest::_internal_set_output_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.output_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EncodeRequest::_internal_mutable_output_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.output_name_.Mutable( GetArenaForAllocation());
}
inline std::string* EncodeRequest::release_output_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:yukikaze.EncodeRequest.output_name)
  return _impl_.output_name_.Release();
}
inline void EncodeRequest::set_allocated_output_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.output_name_.IsDefault()) {
          _impl_.output_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yukikaze.EncodeRequest.output_name)
}

// uint32 service_id = 3;
inline void EncodeRequest::clear_service_id() {
  _impl_.service_id_ = 0u;
}
inline ::uint32_t EncodeRequest::service_id() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.service_id)
  return _internal_service_id();
}
inline void EncodeRequest::set_service_id(::uint32_t value) {
  _internal_set_service_id(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.service_id)
}
inline ::uint32_t EncodeRequest::_internal_service_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_id_;
}
inline void EncodeRequest::_internal_set_service_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.service_id_ = value;
}

// .yukikaze.EncoderType encoder_type = 4;
inline void EncodeRequest::clear_encoder_type() {
  _impl_.encoder_type_ = 0;
}
inline ::yukikaze::EncoderType EncodeRequest::encoder_type() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.encoder_type)
  return _internal_encoder_type();
}
inline void EncodeRequest::set_encoder_type(::yukikaze::EncoderType value) {
  _internal_set_encoder_type(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.encoder_type)
}
inline ::yukikaze::EncoderType EncodeRequest::_internal_encoder_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::yukikaze::EncoderType>(_impl_.encoder_type_);
}
inline void EncodeRequest::_internal_set_encoder_type(::yukikaze::EncoderType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_type_ = value;
}

// string encoder = 13;
inline void EncodeRequest::clear_encoder() {
  _impl_.encoder_.ClearToEmpty();
}
inline const std::string& EncodeRequest::encoder() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.encoder)
  return _internal_encoder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncodeRequest::set_encoder(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.encoder)
}
inline std::string* EncodeRequest::mutable_encoder() {
  std::string* _s = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:yukikaze.EncodeRequest.encoder)
  return _s;
}
inline const std::string& EncodeRequest::_internal_encoder() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encoder_.Get();
}
inline void EncodeRequest::_internal_set_encoder(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_.Set(value, GetArenaForAllocation());
}
inline std::string* EncodeRequest::_internal_mutable_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.encoder_.Mutable( GetArenaForAllocation());
}
inline std::string* EncodeRequest::release_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:yukikaze.EncodeRequest.encoder)
  return _impl_.encoder_.Release();
}
inline void EncodeRequest::set_allocated_encoder(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encoder_.IsDefault()) {
          _impl_.encoder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yukikaze.EncodeRequest.encoder)
}

// string encoder_option = 14;
inline void EncodeRequest::clear_encoder_option() {
  _impl_.encoder_option_.ClearToEmpty();
}
inline const std::string& EncodeRequest::encoder_option() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.encoder_option)
  return _internal_encoder_option();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncodeRequest::set_encoder_option(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_option_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.encoder_option)
}
inline std::string* EncodeRequest::mutable_encoder_option() {
  std::string* _s = _internal_mutable_encoder_option();
  // @@protoc_insertion_point(field_mutable:yukikaze.EncodeRequest.encoder_option)
  return _s;
}
inline const std::string& EncodeRequest::_internal_encoder_option() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encoder_option_.Get();
}
inline void EncodeRequest::_internal_set_encoder_option(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_option_.Set(value, GetArenaForAllocation());
}
inline std::string* EncodeRequest::_internal_mutable_encoder_option() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.encoder_option_.Mutable( GetArenaForAllocation());
}
inline std::string* EncodeRequest::release_encoder_option() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:yukikaze.EncodeRequest.encoder_option)
  return _impl_.encoder_option_.Release();
}
inline void EncodeRequest::set_allocated_encoder_option(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoder_option_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encoder_option_.IsDefault()) {
          _impl_.encoder_option_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yukikaze.EncodeRequest.encoder_option)
}

// bool disable_chapter = 5;
inline void EncodeRequest::clear_disable_chapter() {
  _impl_.disable_chapter_ = false;
}
inline bool EncodeRequest::disable_chapter() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.disable_chapter)
  return _internal_disable_chapter();
}
inline void EncodeRequest::set_disable_chapter(bool value) {
  _internal_set_disable_chapter(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.disable_chapter)
}
inline bool EncodeRequest::_internal_disable_chapter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_chapter_;
}
inline void EncodeRequest::_internal_set_disable_chapter(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_chapter_ = value;
}

// bool disable_delogo = 6;
inline void EncodeRequest::clear_disable_delogo() {
  _impl_.disable_delogo_ = false;
}
inline bool EncodeRequest::disable_delogo() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.disable_delogo)
  return _internal_disable_delogo();
}
inline void EncodeRequest::set_disable_delogo(bool value) {
  _internal_set_disable_delogo(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.disable_delogo)
}
inline bool EncodeRequest::_internal_disable_delogo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_delogo_;
}
inline void EncodeRequest::_internal_set_disable_delogo(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_delogo_ = value;
}

// bool ignore_no_logo = 7;
inline void EncodeRequest::clear_ignore_no_logo() {
  _impl_.ignore_no_logo_ = false;
}
inline bool EncodeRequest::ignore_no_logo() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.ignore_no_logo)
  return _internal_ignore_no_logo();
}
inline void EncodeRequest::set_ignore_no_logo(bool value) {
  _internal_set_ignore_no_logo(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.ignore_no_logo)
}
inline bool EncodeRequest::_internal_ignore_no_logo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_no_logo_;
}
inline void EncodeRequest::_internal_set_ignore_no_logo(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_no_logo_ = value;
}

// bool enable_subtitles = 8;
inline void EncodeRequest::clear_enable_subtitles() {
  _impl_.enable_subtitles_ = false;
}
inline bool EncodeRequest::enable_subtitles() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.enable_subtitles)
  return _internal_enable_subtitles();
}
inline void EncodeRequest::set_enable_subtitles(bool value) {
  _internal_set_enable_subtitles(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.enable_subtitles)
}
inline bool EncodeRequest::_internal_enable_subtitles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_subtitles_;
}
inline void EncodeRequest::_internal_set_enable_subtitles(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_subtitles_ = value;
}

// bool ignore_no_drcsmap = 9;
inline void EncodeRequest::clear_ignore_no_drcsmap() {
  _impl_.ignore_no_drcsmap_ = false;
}
inline bool EncodeRequest::ignore_no_drcsmap() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.ignore_no_drcsmap)
  return _internal_ignore_no_drcsmap();
}
inline void EncodeRequest::set_ignore_no_drcsmap(bool value) {
  _internal_set_ignore_no_drcsmap(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.ignore_no_drcsmap)
}
inline bool EncodeRequest::_internal_ignore_no_drcsmap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_no_drcsmap_;
}
inline void EncodeRequest::_internal_set_ignore_no_drcsmap(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_no_drcsmap_ = value;
}

// .yukikaze.Decoder mpeg2_decoder = 10;
inline void EncodeRequest::clear_mpeg2_decoder() {
  _impl_.mpeg2_decoder_ = 0;
}
inline ::yukikaze::Decoder EncodeRequest::mpeg2_decoder() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.mpeg2_decoder)
  return _internal_mpeg2_decoder();
}
inline void EncodeRequest::set_mpeg2_decoder(::yukikaze::Decoder value) {
  _internal_set_mpeg2_decoder(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.mpeg2_decoder)
}
inline ::yukikaze::Decoder EncodeRequest::_internal_mpeg2_decoder() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::yukikaze::Decoder>(_impl_.mpeg2_decoder_);
}
inline void EncodeRequest::_internal_set_mpeg2_decoder(::yukikaze::Decoder value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mpeg2_decoder_ = value;
}

// .yukikaze.Decoder h264_decoder = 11;
inline void EncodeRequest::clear_h264_decoder() {
  _impl_.h264_decoder_ = 0;
}
inline ::yukikaze::Decoder EncodeRequest::h264_decoder() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.h264_decoder)
  return _internal_h264_decoder();
}
inline void EncodeRequest::set_h264_decoder(::yukikaze::Decoder value) {
  _internal_set_h264_decoder(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.h264_decoder)
}
inline ::yukikaze::Decoder EncodeRequest::_internal_h264_decoder() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::yukikaze::Decoder>(_impl_.h264_decoder_);
}
inline void EncodeRequest::_internal_set_h264_decoder(::yukikaze::Decoder value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.h264_decoder_ = value;
}

// int32 cmoutmask = 12;
inline void EncodeRequest::clear_cmoutmask() {
  _impl_.cmoutmask_ = 0;
}
inline ::int32_t EncodeRequest::cmoutmask() const {
  // @@protoc_insertion_point(field_get:yukikaze.EncodeRequest.cmoutmask)
  return _internal_cmoutmask();
}
inline void EncodeRequest::set_cmoutmask(::int32_t value) {
  _internal_set_cmoutmask(value);
  // @@protoc_insertion_point(field_set:yukikaze.EncodeRequest.cmoutmask)
}
inline ::int32_t EncodeRequest::_internal_cmoutmask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmoutmask_;
}
inline void EncodeRequest::_internal_set_cmoutmask(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cmoutmask_ = value;
}

// -------------------------------------------------------------------

// EncodeResponse

// -------------------------------------------------------------------

// StatusRequest

// -------------------------------------------------------------------

// StatusResponse

// bytes log = 1;
inline void StatusResponse::clear_log() {
  _impl_.log_.ClearToEmpty();
}
inline const std::string& StatusResponse::log() const {
  // @@protoc_insertion_point(field_get:yukikaze.StatusResponse.log)
  return _internal_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusResponse::set_log(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yukikaze.StatusResponse.log)
}
inline std::string* StatusResponse::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:yukikaze.StatusResponse.log)
  return _s;
}
inline const std::string& StatusResponse::_internal_log() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_.Get();
}
inline void StatusResponse::_internal_set_log(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.log_.Mutable( GetArenaForAllocation());
}
inline std::string* StatusResponse::release_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:yukikaze.StatusResponse.log)
  return _impl_.log_.Release();
}
inline void StatusResponse::set_allocated_log(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_.IsDefault()) {
          _impl_.log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yukikaze.StatusResponse.log)
}

// -------------------------------------------------------------------

// CancelRequest

// -------------------------------------------------------------------

// CancelResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace yukikaze


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::yukikaze::Decoder> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::yukikaze::Decoder>() {
  return ::yukikaze::Decoder_descriptor();
}
template <>
struct is_proto_enum<::yukikaze::EncoderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::yukikaze::EncoderType>() {
  return ::yukikaze::EncoderType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_yukikaze_2eproto_2epb_2eh
